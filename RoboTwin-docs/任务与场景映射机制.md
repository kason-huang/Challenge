# RoboTwin 任务与场景映射机制

## 概述

RoboTwin通过**场景信息（scene_info）**实现任务与场景的映射。这种设计允许：
1. **数据收集阶段**：保存每个episode的场景参数（物体类型、位置、使用的机械臂等）
2. **评测阶段**：加载之前保存的场景信息，确保评测使用相同的场景配置
3. **语言指令生成**：基于场景参数生成多样化的指令模板

---

## 一、映射架构

```
┌──────────────────────────────────────────────────────────────────────────┐
│  任务定义 (Task Definition)                                      │
│  envs/stack_bowls_two.py                                      │
│  ├─ load_actors():     定义任务物体和位置               │
│  ├─ play_once():       专家动作序列                         │
│  └─ check_success():   成功判断条件                       │
└──────────────────────────────────────────────────────────────────────────┘
                         │
                         │ 定义episode信息
                         ▼
┌──────────────────────────────────────────────────────────────────────────┐
│  场景信息 (Scene Info)                                        │
│  scene_info.json                                              │
│  {                                                           │
│    "episode_0": {                                           │
│      "info": {                                                │
│        "{A}": "002_bowl/base3",        # 物体A的类型     │
│        "{B}": "002_bowl/base3",        # 物体B的类型     │
│        "{a}": "left",                     # 使用的左/右臂    │
│        "{b}": "left",                     # 使用的左/右臂    │
│      }                                                         │
│    },                                                          │
│    "episode_1": {...},                                        │
│    "episode_2": {...},                                        │
│    ...                                                         │
│  }                                                           │
└──────────────────────────────────────────────────────────────────────────┘
                         │
                         │ 用于指令生成和评测复现
                         ▼
┌──────────────────────────────────────────────────────────────────────────┐
│  语言指令模板 (Task Instructions)                                │
│  task_instruction/stack_bowls_two.json                            │
│  {                                                           │
│    "seen": [50条seen指令],                                │
│    "unseen": [10条unseen指令]                          │
│  }                                                           │
│  示例：                                                       │
│  - "Stack {A} on top of {B}"                              │
│  - "Use {a} arm to stack {A} on {B}"                   │
│  - "Pick {A}, position on table, and place {B} over it." │
└──────────────────────────────────────────────────────────────────────────┘
                         │
                         │ 结合场景信息和指令模板
                         ▼
┌──────────────────────────────────────────────────────────────────────────┐
│  最终指令 (Final Instructions)                                    │
│  - "Stack medium-sized yellow bowl on top of light blue ceramic bowl"    │
│  - "Use the left arm to stack 002_bowl/base3 on 002_bowl/base3"│
│  - "Pick the medium-sized yellow bowl, position on table, and       │
│    place the light blue ceramic bowl over it."                       │
└──────────────────────────────────────────────────────────────────────────┘
```

---

## 二、场景信息结构

### 2.1 scene_info.json 位置

```
{task_name}/{task_config}/
└── scene_info.json
```

**示例路径**：
```
stack_bowls_two/demo_randomized/scene_info.json
beat_block_hammer/demo_clean/scene_info.json
```

### 2.2 scene_info.json 结构

```json
{
  "episode_0": {
    "info": {
      // 物体类型（从RoboTwin-OD物体库索引）
      "{A}": "002_bowl/base3",
      "{B}": "002_bowl/base3",

      // 使用的机械臂
      "{a}": "left",
      "{b}": "left",

      // 其他任务特定信息（可选）
      "{C}": "...",
      "{c}": "..."
    }
  },
  "episode_1": {
    "info": {
      "{A}": "002_bowl/base3",
      "{B}": "002_bowl/base3",
      "{a}": "right",
      "{b}": "right"
    }
  },
  ...
  "episode_N": {
    "info": {...}
  }
}
```

### 2.3 信息关键字段说明

| 字段 | 含义 | 示例 |
|------|------|------|
| **{A}, {B}, {C}...** | 大写字母占位符，表示任务中的物体 | `"{A}": "002_bowl/base3"` |
| **{a}, {b}, {c}...** | 小写字母占位符，表示使用的机械臂 | `"{a}": "left"` |
| **object_type** | 物体类型字符串 | `"bowl"`, `"bottle"`, `"hammer"` |
| **object_index** | 物体模型ID | `3` (002_bowl的第3个模型) |
| **pose** | 物体初始位姿 | `{"p": [x,y,z], "q": [x,y,z,w]}` |

### 2.4 RoboTwin-OD 物体库结构

```
description/objects_description/
├── 001_bottle/
│   └── {model_index}.json
├── 002_bowl/
│   ├── 0.json          # 第一个碗模型
│   ├── 1.json          # 第二个碗模型
│   ├── 2.json          # 第三个碗模型
│   └── 3.json          # 第四个碗模型
├── 003_plate/
├── ...
└── 120_shoe/
    └── {model_index}.json
```

**物体描述文件示例**：`002_bowl/3.json`

```json
{
  "seen": [
    "A medium-sized yellow bowl",
    "A light blue ceramic bowl",
    "A small wooden bowl",
    ...  # 共12个seen描述（训练用）
  ],
  "unseen": [
    "A green metal bowl",
    "A dark plastic bowl",
    ...  # 共3个unseen描述（评测用）
  ]
}
```

---

## 三、映射流程详解

### 阶段1：数据收集时生成scene_info

#### 3.1 任务中的info字典定义

**stack_bowls_two任务**：

```python
class stack_bowls_two(Base_Task):
    def play_once(self):
        # 执行专家轨迹后
        self.info["info"] = {
            "{A}": f"002_bowl/base3",     # 物体A的类型
            "{B}": f"002_bowl/base3",     # 物体B的类型
            "{a}": str(arm_tag1),         # 哪个臂抓了A
            "{b}": str(arm_tag2),         # 哪个臂抓了B
        }

        return self.info
```

**其他任务示例**：

```python
# beat_block_hammer任务
self.info["info"] = {
    "{A}": "006_hammer/base1",   # 锤子
    "{B}": "004_block/base3",     # 块
}

# place_shoe任务
self.info["info"] = {
    "{A}": "120_shoe/base2",     # 鞋
    "{B}": "003_plate/base4",     # 盘
    "{a}": "left",               # 使用的臂
}
```

#### 3.2 收集脚本中保存scene_info

**collect_data.py**（第212-225行）：

```python
# 1. 设置保存路径
info_file_path = os.path.join(args["save_path"], "scene_info.json")

# 2. 初始化scene_info（如果首次运行）
if not os.path.exists(info_file_path):
    with open(info_file_path, "w", encoding="utf-8") as file:
        json.dump({}, file, ensure_ascii=False)

# 3. 加载已有scene_info
with open(info_file_path, "r", encoding="utf-8") as file:
    info_db = json.load(file)

# 4. 执行专家轨迹并获取episode信息
info = TASK_ENV.play_once()

# 5. 添加到scene_info字典
info_db[f"episode_{episode_idx}"] = info

# 6. 保存更新后的scene_info
with open(info_file_path, "w", encoding="utf-8") as file:
    json.dump(info_db, file, ensure_ascii=False, indent=4)
```

**关键特点**：
- **增量式保存**：每次成功episode后追加，不覆盖已有数据
- **JSON格式**：易于解析和人类可读
- **结构化存储**：每个episode独立保存，便于后续检索

---

### 阶段2：评测时加载scene_info

#### 3.1 指令生成脚本加载机制

**generate_episode_instructions.py**（第139-148行）：

```python
def load_scene_info(task_name: str, setting: str, scene_info_path: str) -> Dict[str, Dict]:
    """Load scene info from JSON file in data directory."""
    file_path = os.path.join(
        parent_directory,  # RoboTwin/description/utils/
        f"../../{scene_info_path}/{task_name}/{setting}/scene_info.json"
    )

    try:
        with open(file_path, "r") as file:
            scene_data = json.load(file)
        return scene_data
    except FileNotFoundError:
        print(f"\033[1mERROR: Scene info file '{file_path}' not found.\033[0m")
        exit(1)
    except json.JSONDecodeError:
        print(f"\033[1mERROR: Scene info file '{file_path}' contains invalid JSON.\033[0m}")
        exit(1)
```

**调用方式**：
```bash
# 在collect_data.py最后
command = (
    f"cd description && "
    f"bash gen_episode_instructions.sh "
    f"{args['task_name']} "         # stack_bowls_two
    f"{args['task_config']} "      # demo_randomized
    f"{args['language_num']}"      # 100
)
os.system(command)
```

#### 3.2 提取episode参数

```python
def extract_episodes_from_scene_info(scene_info: Dict) -> List[Dict[str, str]]:
    """Extract episode parameters from scene_info."""
    episodes = []

    for episode_key, episode_data in scene_info.items():
        if "info" in episode_data:
            episodes.append(episode_data["info"])
        else:
            episodes.append(dict())  # 空字典（兼容老数据）

    return episodes

# 示例输出：
# [
#   {"{A}": "002_bowl/base3", "{B}": "002_bowl/base3", "{a}": "left", "{b}": "left"},
#   {"{A}": "002_bowl/base3", "{B}": "002_bowl/base3", "{a}": "right", "{b}": "right"},
#   ...
# ]
```

---

### 阶段3：指令生成与替换

#### 3.1 加载任务指令模板

```python
def load_task_instructions(task_name: str) -> Dict[str, Any]:
    """Load task instructions from JSON file."""
    file_path = os.path.join(
        parent_directory,  # RoboTwin/description/utils/
        f"../task_instruction/{task_name}.json"
    )

    with open(file_path, "r") as file:
        task_data = json.load(file)
    return task_data

# 返回：
# {
#   "seen": [...50条seen指令...],
#   "unseen": [...10条unseen指令...]
# }
```

#### 3.2 过滤匹配的指令

```python
def filter_instructions(instructions: List[str], episode_params: Dict[str, str]) -> List[str]:
    """
    Filter instructions to only include those that have all placeholders
    matching available episode parameters.
    """
    filtered_instructions = []
    random.shuffle(instructions)  # 随机化顺序

    for instruction in instructions:
        # 提取指令中的占位符：{A}, {B}, {a}, {b}等
        placeholders = extract_placeholders(instruction)  # 正则提取

        # 移除episode_params中的{}符号
        stripped_episode_params = {
            key.strip("{}"): value
            for key, value in episode_params.items()
        }

        # 提取机械臂相关参数（小写字母）
        arm_params = {
            key for key in stripped_episode_params.keys()
            if len(key) == 1 and "a" <= key <= "z"
        }

        # 非机械臂参数（物体等）
        non_arm_params = set(stripped_episode_params.keys()) - arm_params

        # 接受条件：
        # 1. 完全匹配所有占位符
        # OR
        # 2. 只缺少机械臂参数（可以不指定手臂）
        if set(placeholders) == set(stripped_episode_params.keys()) or (
                arm_params and
                set(placeholders).union(arm_params) == set(stripped_episode_params.keys()) and
                not arm_params.intersection(set(placeholders))
        ):
            filtered_instructions.append(instruction)

    return filtered_instructions

# 示例：
# episode_params = {"{A}": "002_bowl/base3", "{B}": "002_bowl/base3"}
# instruction = "Stack {A} on top of {B}"
# → placeholders = ["{A}", "{B}"] → 完全匹配，接受
#
# episode_params = {"{A}": "002_bowl/base3", "{B}": "002_bowl/base3", "{a}": "left"}
# instruction = "Use {a} arm to stack {A} on {B}"
# → placeholders = ["{A}", "{B}", "{a}"] → 完全匹配，接受
```

#### 3.3 占位符替换（生成最终指令）

```python
def replace_placeholders(instruction: str, episode_params: Dict[str, str]) -> str:
    """
    Replace all {X} placeholders in instruction with corresponding values.
    For arm placeholders {[a-z]}, add 'the ' in front and ' arm' after the value.
    """
    stripped_episode_params = {
        key.strip("{}"): value
        for key, value in episode_params.items()
    }

    for key, value in stripped_episode_params.items():
        placeholder = "{" + key + "}"

        # === 情况1：物体描述（路径包含/或\） ===
        if "\\" in value or "/" in value:
            json_path = os.path.join(
                parent_directory,
                "../objects_description",
                value + ".json"
            )

            # 加载物体描述文件
            if os.path.exists(json_path):
                with open(json_path, "r") as file:
                    json_data = json.load(file)

                # 随机选择一个seen描述
                description = random.choice(json_data.get("seen", []))
                value = f"the {description}"  # 添加"the"前缀

        # === 情况2：机械臂（单个小写字母） ===
        elif len(key) == 1 and "a" <= key <= "z":
            value = f"the {value} arm"

        # === 情况3：其他（直接使用） ===
        else:
            value = f"{value}"

        # 替换占位符
        instruction = instruction.replace(placeholder, value)

    return instruction

# 示例：
# episode_params = {
#   "{A}": "002_bowl/base3",
#   "{B}": "002_bowl/base3",
#   "{a}": "left"
# }
# instruction_template = "Use {a} arm to stack {A} on {B}"
#
# 替换步骤：
# 1. {a} → "the left arm"
# 2. {A} → 随机选择"002_bowl/3.json"的seen描述
#    例如："A medium-sized yellow bowl"
# 3. {B} → 随机选择另一个描述
#    例如："A light blue ceramic bowl"
#
# 最终指令：
# "Use the left arm to stack A medium-sized yellow bowl on top of A light blue ceramic bowl"
```

#### 3.4 Unseen描述生成

```python
def replace_placeholders_unseen(instruction: str, episode_params: Dict[str, str]) -> str:
    """Same as replace_placeholders but uses 'unseen' descriptions."""
    # ... 类似逻辑，但使用json_data.get("unseen", [])

    # 如果unseen为空，回退到seen
    description = random.choice(json_data.get("unseen", json_data.get("seen", [])))
```

#### 3.5 生成多样化指令

```python
def generate_episode_descriptions(task_name: str, episodes: List[Dict[str, str]], max_descriptions: int = 1000000):
    """
    Generate descriptions for episodes by replacing placeholders in instructions
    with parameter values.
    """
    # 1. 加载任务指令模板
    task_data = load_task_instructions(task_name)
    seen_instructions = task_data.get("seen", [])
    unseen_instructions = task_data.get("unseen", [])

    all_generated_descriptions = []

    # 2. 处理每个episode
    for i, episode in enumerate(episodes):
        # 过滤匹配的seen和unseen指令
        filtered_seen = filter_instructions(seen_instructions, episode)
        filtered_unseen = filter_instructions(unseen_instructions, episode)

        # 3. 生成seen描述（最多max_descriptions条）
        seen_episode_descriptions = []
        flag_seen = True
        while len(seen_episode_descriptions) < max_descriptions and flag_seen and filtered_seen:
            for instruction in filtered_seen:
                if len(seen_episode_descriptions) >= max_descriptions:
                    flag_seen = False
                    break
                description = replace_placeholders(instruction, episode)
                seen_episode_descriptions.append(description)

        # 4. 生成unseen描述（最多max_descriptions条）
        unseen_episode_descriptions = []
        flag_unseen = True
        while len(unseen_episode_descriptions) < max_descriptions and flag_unseen and filtered_unseen:
            for instruction in filtered_unseen:
                if len(unseen_episode_descriptions) >= max_descriptions:
                    flag_unseen = False
                    break
                description = replace_placeholders_unseen(description, episode)
                unseen_episode_descriptions.append(description)

        # 5. 保存该episode的所有描述
        all_generated_descriptions.append({
            "episode_index": i,
            "seen": seen_episode_descriptions,        # 默认100条
            "unseen": unseen_episode_descriptions,      # 默认100条
        })

    return all_generated_descriptions
```

#### 3.6 保存生成的指令

```python
def save_episode_descriptions(task_name: str, setting: str, generated_descriptions: List[Dict]):
    """Save generated descriptions to output files."""
    output_dir = os.path.join(
        parent_directory,
        f"../../data/{task_name}/{setting}/instructions"
    )

    os.makedirs(output_dir, exist_ok=True)

    for episode_desc in generated_descriptions:
        episode_index = episode_desc["episode_index"]
        output_file = os.path.join(output_dir, f"episode{episode_index}.json")

        with open(output_file, "w") as file:
            json.dump(
                {
                    "seen": episode_desc.get("seen", []),
                    "unseen": episode_desc.get("unseen", []),
                },
                file,
                indent=2,
            )
```

**保存结构**：

```
{task_name}/{task_config}/instructions/
├── episode0.json     # episode_0的100条seen + 100条unseen指令
├── episode1.json     # episode_1的100条seen + 100条unseen指令
├── episode2.json
└── ...
```

---

### 阶段4：评测时加载和采样指令

#### 4.1 评测脚本中的指令加载

**eval_policy.py**（使用generate_episode_descriptions函数）：

```python
# 在评测循环中，专家验证成功后：

# 1. 调用指令生成函数
episode_info_list = [episode_info["info"]]
results = generate_episode_descriptions(
    args["task_name"],      # "stack_bowls_two"
    episode_info_list,         # [{"{A}": "002_bowl/base3", ...}]
    test_num                  # 100（默认）
)

# 2. results[0]包含第一个episode的所有生成指令
# results[0][instruction_type]包含：
#   - "template": 使用模板指令（不过滤）
#   - "semantic": 使用语义多样化指令
#   - "descriptive": 使用描述性指令（seen描述）

# 3. 随机选择一条指令
instruction = np.random.choice(results[0][instruction_type])

# 4. 设置给环境
TASK_ENV.set_instruction(instruction)
```

#### 4.2 指令采样策略

**instruction_type选项**：

| 类型 | 来源 | 特点 | 用途 |
|------|------|------|------|
| **template** | 直接从指令模板采样，不过滤 | 保留原始模板结构 | 测试模型对模板指令的鲁棒性 |
| **semantic** | 经过filter_instructions筛选的指令 | 确保占位符匹配episode参数 | 测试模型语义理解能力 |
| **descriptive** | 使用物体描述（seen）替换占位符 | 自然语言描述物体 | 测试模型视觉-语言对齐 |

**采样示例**：

```
episode_params = {
  "{A}": "002_bowl/base3",
  "{B}": "002_bowl/base3",
  "{a}": "left"
}

seen_descriptions = [
  "Stack {A} on top of {B}"  # 模板式
  "Use {a} arm to stack {A} on {B}"
  "Pick {A}, position on table, and place {B} over it."
  # ... (100+条）
]

instruction_type = "descriptive"
→ 随机选择：
  "Stack the medium-sized yellow bowl on top of the light blue ceramic bowl"
  或
  "Use the left arm to stack a small wooden bowl on top of a ceramic bowl"
  或
  "Pick up the light blue ceramic bowl, position on table, and place the medium-sized yellow bowl over it."
```

---

## 四、映射机制特点总结

### 4.1 三层映射架构

```
┌─────────────────────────────────────────────────────────────┐
│ 第1层：任务定义 (Task)                                 │
│ 定义episode参数模板（{A}, {B}, {a}...）           │
└─────────────────────────────────────────────────────────────┘
                      │ 在play_once中返回info字典
                      ▼
┌─────────────────────────────────────────────────────────────┐
│ 第2层：场景信息 (Scene Info)                            │
│ scene_info.json存储episode参数的实例化值                │
│ episode_0: {"{A}": "002_bowl/base3", ...}          │
│ episode_1: {"{A}": "002_bowl/base3", ...}          │
└─────────────────────────────────────────────────────────────┘
                      │ 用于指令生成和评测复现
                      ▼
┌─────────────────────────────────────────────────────────────┐
│ 第3层：指令系统 (Instructions)                           │
│ 指令模板 + 物体描述 → 最终指令                  │
│ "Stack {A} on top of {B}" + 物体描述 =               │
│ "Stack medium-sized yellow bowl on top of ..."            │
└─────────────────────────────────────────────────────────────┘
```

### 4.2 关键特性

| 特性 | 实现机制 | 优势 |
|------|----------|------|
| **参数化设计** | 使用占位符{A}, {B}, {a}等 | 灵活组合不同场景和指令 |
| **类型分离** | 物体类型（大写） vs 机械臂（小写） | 清晰区分角色 |
| **描述库分离** | seen（训练） vs unseen（评测） | 避免数据泄漏 |
| **多样化生成** | 100+指令变体 × 15物体描述 = 1500+指令 | 测试语言鲁棒性 |
| **可复现性** | scene_info精确记录episode参数 | 评测可精确复现 |

### 4.3 数据流

```
数据收集阶段：
1. setup_demo(): 创建物体，设置初始位置
2. play_once(): 执行专家轨迹，返回info字典
3. 保存scene_info.json: episode_{idx} → {info}
4. 调用gen_episode_instructions.sh: 生成指令

评测阶段：
1. 加载scene_info.json: 读取episode参数
2. 加载指令模板: task_instruction/{task}.json
3. 加载物体描述: objects_description/{type}/{model}.json
4. 生成/采样指令: 替换占位符 → 最终指令
5. 设置指令: TASK_ENV.set_instruction(instruction)
6. 执行策略: 使用指令条件下的场景进行评测
```

---

## 五、示例完整流程

### 5.1 场景1：双左臂堆叠

**scene_info.json**：
```json
{
  "episode_0": {
    "info": {
      "{A}": "002_bowl/base3",
      "{B}": "002_bowl/base3",
      "{a}": "left",
      "{b}": "left"
    }
  }
}
```

**生成的指令（descriptive类型）**：
```
1. "Stack the medium-sized yellow bowl on top of the light blue ceramic bowl using the left arm"
2. "Use the left arm to pick up a small wooden bowl and place it on top of the medium-sized yellow bowl"
3. "Pick the light blue ceramic bowl, position on table, and place the medium-sized yellow bowl over it"
... (100+ variations)
```

### 5.2 场景2：双右臂堆叠

**scene_info.json**：
```json
{
  "episode_1": {
    "info": {
      "{A}": "002_bowl/base3",
      "{B}": "002_bowl/base3",
      "{a}": "right",
      "{b}": "right"
    }
  }
}
```

**生成的指令（descriptive类型）**：
```
1. "Stack the medium-sized yellow bowl on top of the light blue ceramic bowl using the right arm"
2. "Use the right arm to pick up a small wooden bowl and place it on top of the medium-sized yellow bowl"
... (100+ variations)
```

### 5.3 评测时采样

```python
# 在eval_policy.py中
instruction_type = "descriptive"
instruction = np.random.choice(results[0][instruction_type])

# 可能随机到：
instruction = "Stack the medium-sized yellow bowl on top of the light blue ceramic bowl using the left arm"

TASK_ENV.set_instruction(instruction)

# 策略在以下条件下执行：
# - 场景：episode_0的物体配置（两个碗）
# - 指令：使用left arm堆叠medium-sized yellow bowl on top of light blue ceramic bowl
# - 目标：成功堆叠两个碗
```

---

## 六、总结

RoboTwin的任务与场景映射机制是一个**三层参数化架构**：

1. **任务定义层**（Task）：定义参数模板（{A}, {B}, {a}）
2. **场景信息层**（Scene Info）：存储实例化的episode参数
3. **指令系统层**（Instructions）：结合模板和描述生成多样化指令

**核心优势**：
- **可扩展性**：新任务只需定义info字典结构
- **可复现性**：scene_info确保评测使用完全相同的场景
- **语言多样性**：seen/unseen分离 + 多重占位符替换
- **灵活性**：支持模板、语义、描述性多种指令类型
- **模块化设计**：任务、场景、指令三层解耦，便于维护

这种设计使得RoboTwin能够支持50+任务，并为每个任务生成1500+条多样化指令，为语言条件下的策略评测提供了强大的基础设施。
